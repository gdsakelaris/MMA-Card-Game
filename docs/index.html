<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMA Warriors - MMA Card Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(1200px 600px at 20% 0%, #111 0%, #000 60%, #020202 100%);
            color: #fff;
            min-height: 100vh;
            padding: 10px;
        }

        .game-container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .game-header {
            text-align: left;
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(25,25,25,0.9), rgba(10,10,10,0.9));
            border-radius: 5px;
            border: 2px solid #ffffff;
            box-shadow: 0 0 20px rgba(255,255,255,0.35), inset 0 0 10px rgba(255,255,255,0.12);
        }

        .game-header h1 {
            font-size: 1.8em;
            color: #d20a0a;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 5px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .game-stats {
            display: flex;
            justify-content: flex-start;
            margin-top: 5px;
            gap: 15px;
        }

        .stat-box {
            background: #1a1a1a;
            padding: 5px 15px;
            border-radius: 3px;
            font-size: 0.95em;
            border: 1px solid #333;
        }

        .stat-label {
            color: #999;
            font-size: 0.8em;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.1em;
            color: #fff;
        }

        .game-board {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto auto auto;
            gap: 10px;
            min-height: 500px;
        }

        .opponent-area, .player-area {
            background: linear-gradient(160deg, rgba(26,26,26,0.95), rgba(15,15,15,0.95));
            border-radius: 5px;
            padding: 10px;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 20px rgba(255,255,255,0.04) inset;
        }

        .opponent-area {
            border: 2px solid #d20a0a;
            box-shadow: 0 0 18px rgba(210,10,10,0.15);
        }

        .player-area {
            border: 2px solid #00e1ff;
            box-shadow: 0 0 18px rgba(0,225,255,0.15);
        }

        .area-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }

        .player-name {
            font-size: 1.1em;
            font-weight: bold;
            min-width: 80px;
        }

        .health-bar {
            flex: 1;
            max-width: 250px;
            margin: 0 10px;
        }

        .health-bar-bg {
            background: #333;
            height: 20px;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
        }

        .health-bar-fill {
            height: 100%;
            background: #d20a0a;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85em;
        }

        .player-area .health-bar-fill {
            background: #fff;
            color: #000;
        }

        .fighter-zone {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }

        .bench-zone {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .bench-card {
            width: 120px;
            padding: 8px;
        }

        .hand-counter {
            margin-top: 4px;
            font-size: 0.85em;
            color: #aaa;
        }

        .card {
            background: linear-gradient(180deg, #0f0f12 0%, #121216 60%, #0a0a0d 100%);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            padding: 10px;
            width: 160px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 24px rgba(0, 225, 255, 0.2);
            border-color: #00e1ff;
        }

        .fighter-card:hover {
            box-shadow: 0 10px 24px rgba(100, 150, 255, 0.4);
            border-color: #6c9eff;
        }

        .technique-card:hover {
            box-shadow: 0 10px 24px rgba(255, 80, 80, 0.4);
            border-color: #ff5050;
        }

        .defense-card:hover {
            box-shadow: 0 10px 24px rgba(255, 215, 0, 0.4);
            border-color: #ffd700;
        }

        .corner-card:hover {
            box-shadow: 0 10px 24px rgba(100, 255, 100, 0.4);
            border-color: #64ff64;
        }

        .card.fighter-card {
            width: 180px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 60%, #0f1626 100%);
            border-color: rgba(100, 150, 255, 0.5);
        }

        .card.technique-card {
            background: linear-gradient(180deg, #2e1010 0%, #1f0b0b 60%, #140808 100%);
            border-color: rgba(255, 80, 80, 0.5);
        }

        .card.defense-card {
            background: linear-gradient(180deg, #2e2810 0%, #1f1c0b 60%, #141008 100%);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .card.corner-card {
            background: linear-gradient(180deg, #1a2e1a 0%, #132419 60%, #0d1a10 100%);
            border-color: rgba(100, 255, 100, 0.5);
        }

        .card.opponent-card {
            border-color: #d20a0a;
        }

        .card.opponent-card:hover {
            box-shadow: 0 10px 24px rgba(210, 10, 10, 0.35);
            border-color: #d20a0a;
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .card-header {
            font-weight: bold;
            font-size: 0.95em;
            margin-bottom: 6px;
            color: #fff;
            letter-spacing: 0.5px;
        }

        .opponent-card .card-header {
            color: #d20a0a;
        }

        .card-type {
            font-size: 0.7em;
            color: #999;
            margin-bottom: 5px;
        }

        .fighter-card .card-type {
            color: #6c9eff;
        }

        .technique-card .card-type {
            color: #ff5050;
        }

        .defense-card .card-type {
            color: #ffd700;
        }

        .corner-card .card-type {
            color: #64ff64;
        }

        .card-stats {
            margin: 6px 0;
        }

        .card-stat {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            font-size: 0.8em;
        }

        .card-stat-label {
            color: #999;
        }

        .card-stat-value {
            font-weight: bold;
            color: #fff;
        }

        .card-energy {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, #00e1ff, #007a8a);
            color: #fff;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.95em;
            border: 1px solid rgba(255,255,255,0.6);
            box-shadow: 0 0 8px rgba(0,225,255,0.5);
        }

        .card-ability {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #333;
            font-size: 0.75em;
            font-style: italic;
            color: #d20a0a;
        }

        .technique-card .card-ability {
            color: #ff5050;
        }

        .defense-card .card-ability {
            color: #ffd700;
        }

        .corner-card .card-ability {
            color: #64ff64;
        }

        .hand-area {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 8px;
            background: #0a0a0a;
            border-radius: 5px;
            min-height: 220px;
            border: 1px solid #333;
        }

        .hand-label {
            font-weight: bold;
            margin-bottom: 6px;
            color: #fff;
            font-size: 0.9em;
        }

        .center-area {
            background: linear-gradient(135deg, rgba(26,26,32,0.95), rgba(12,12,16,0.95));
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            border: 1px solid #333;
            box-shadow: 0 0 16px rgba(0,225,255,0.1);
            max-width: 560px;
            justify-self: center;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 8px;
        }

        .btn {
            padding: 8px 20px;
            font-size: 0.95em;
            font-weight: bold;
            border: 2px solid #fff;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: scale(1.03);
        }

        .btn-primary {
            background: linear-gradient(135deg, #00e1ff, #007a8a);
            color: #fff;
            border-color: #00e1ff;
            box-shadow: 0 0 10px rgba(0,225,255,0.2);
        }

        .btn-primary:hover {
            filter: brightness(1.08);
            transform: translateY(-1px) scale(1.02);
        }

        .btn-danger {
            background: #d20a0a;
            color: #fff;
            border-color: #d20a0a;
        }

        .btn-danger:hover {
            background: #fff;
            color: #d20a0a;
            border-color: #fff;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-log {
            background: linear-gradient(160deg, rgba(26,26,26,0.95), rgba(15,15,15,0.95));
            border-radius: 5px;
            padding: 10px;
            border: 1px solid #333;
            grid-column: 2;
            grid-row: 1 / span 3;
            max-height: none;
            height: 100%;
            overflow-y: auto;
            box-shadow: 0 0 18px rgba(255,255,255,0.05) inset;
        }

        .game-log h3 {
            margin-bottom: 6px;
            color: #fff;
            font-size: 1em;
        }

        .log-entry {
            padding: 4px;
            margin: 3px 0;
            border-left: 2px solid #fff;
            padding-left: 8px;
            font-size: 0.85em;
        }

        .log-item {
            padding: 4px;
            margin: 3px 0;
            border-left: 3px solid #999;
            padding-left: 8px;
            font-size: 0.85em;
            color: #ddd;
            background: rgba(255,255,255,0.03);
            border-radius: 3px;
        }

        .log-item.opponent-log {
            border-left-color: #d20a0a;
            background: rgba(210,10,10,0.08);
        }

        .log-item.player-log {
            border-left-color: #00e1ff;
            background: rgba(0,225,255,0.08);
        }

        #gameLogMessages {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .log-entry.opponent {
            border-left-color: #d20a0a;
        }

        .log-entry.damage {
            color: #d20a0a;
        }

        .log-entry.heal {
            color: #4ecca3;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(160deg, rgba(26,26,26,0.98), rgba(15,15,15,0.98));
            padding: 30px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            border: 3px solid #00e1ff;
            box-shadow: 0 0 30px rgba(0,225,255,0.2);
        }

        /* Opening fighter selection */
        .selection-modal .modal-content {
            max-width: 760px;
        }
        .select-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-top: 10px;
        }
        .select-card {
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            padding: 8px;
            width: 180px;
            transition: transform 0.15s, box-shadow 0.15s, border-color 0.15s;
        }
        .select-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: #00e1ff;
            box-shadow: 0 12px 20px rgba(0,225,255,0.15);
            cursor: pointer;
        }

        .modal-content h2 {
            font-size: 2em;
            margin-bottom: 15px;
            color: #fff;
        }

        .modal-content.defeat h2 {
            color: #d20a0a;
        }

        .positional-advantage {
            display: inline-block;
            background: #d20a0a;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 4px;
        }

        /* Fighter stamina bar */
        .stamina-bar-bg {
            background: #333;
            height: 8px;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            border: 1px solid #555;
            margin-top: 6px;
        }

        .stamina-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecca3, #ffd700, #e94560);
            transition: width 0.3s ease;
        }

        .empty-slot {
            width: 180px;
            height: 250px;
            border: 2px dashed #333;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            font-style: italic;
            font-size: 0.85em;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .shake {
            animation: shake 0.3s ease-in-out;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(210, 10, 10, 0.5); }
            50% { box-shadow: 0 0 20px rgba(210, 10, 10, 0.8); }
        }

        @keyframes glowBlue {
            0%, 100% { box-shadow: 0 0 10px rgba(100, 150, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(100, 150, 255, 0.8); }
        }

        @keyframes glowRed {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 80, 80, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 80, 80, 0.8); }
        }

        @keyframes glowYellow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        @keyframes glowGreen {
            0%, 100% { box-shadow: 0 0 10px rgba(100, 255, 100, 0.5); }
            50% { box-shadow: 0 0 20px rgba(100, 255, 100, 0.8); }
        }

        .glow {
            animation: glow 1s ease-in-out infinite;
        }

        .fighter-card.glow {
            animation: glowBlue 1s ease-in-out infinite;
        }

        .technique-card.glow {
            animation: glowRed 1s ease-in-out infinite;
        }

        .defense-card.glow {
            animation: glowYellow 1s ease-in-out infinite;
        }

        .corner-card.glow {
            animation: glowGreen 1s ease-in-out infinite;
        }

        /* Action feed and floating combat text */
        .action-feed { /* global (legacy) */
            position: fixed;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
        }
        .inline-action-feed { /* per-side inline feed */
            margin-top: 4px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            min-height: 20px;
            flex: 1;
            pointer-events: none;
            width: 100%;
        }
        .action-item {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.25);
            border-left-width: 3px;
            color: #fff;
            padding: 3px 8px;
            border-radius: 3px;
            text-align: left;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: block;
            width: 25%;
            font-size: 0.8em;
            line-height: 1.2;
        }
        .action-item.player { border-left-color: #00e1ff; }
        .action-item.opponent { border-left-color: #d20a0a; }
        .action-item.damage { background: rgba(210,10,10,0.18); }
        .action-item.heal { background: rgba(78,204,163,0.18); }
        .action-item.advantage { background: rgba(210,210,10,0.18); }
        .action-item.ko { background: rgba(210,10,10,0.28); font-weight: bold; }

        /* Card type themed messages */
        .action-item.card-fighter {
            background: rgba(100, 150, 255, 0.15) !important;
            border-left-color: #6c9eff !important;
        }
        .action-item.card-technique {
            background: rgba(255, 80, 80, 0.15) !important;
            border-left-color: #ff5050 !important;
        }
        .action-item.card-defense {
            background: rgba(255, 215, 0, 0.15) !important;
            border-left-color: #ffd700 !important;
        }
        .action-item.card-corner {
            background: rgba(100, 255, 100, 0.15) !important;
            border-left-color: #64ff64 !important;
        }

        .action-item.new-message {
            animation: messageSlideIn 0.3s ease-out;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes feedIn {
            from { opacity: 0; transform: translate(-50%, -8px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        @keyframes feedOut {
            to { opacity: 0; transform: translate(-50%, -8px); }
        }

        .float-text {
            position: absolute;
            left: 50%;
            top: 30%;
            transform: translateX(-50%);
            color: #fff;
            font-weight: bold;
            text-shadow: 0 2px 6px rgba(0,0,0,0.7);
            animation: rise 0.8s ease-out forwards;
            pointer-events: none;
        }
        .float-text.damage { color: #ff5b5b; }
        .float-text.heal { color: #4ecca3; }
        .float-text.info { color: #ffd700; }
        @keyframes rise {
            from { opacity: 0; transform: translate(-50%, 12px) scale(0.95); }
            30% { opacity: 1; }
            to { opacity: 0; transform: translate(-50%, -22px) scale(1.05); }
        }

        #turnIndicator {
            font-size: 1.2em;
            margin-bottom: 5px;
            color: #fff;
        }

        #actionPrompt {
            font-size: 0.9em;
            color: #999;
            margin-bottom: 8px;
        }

        /* Mobile Responsive Design */
        @media screen and (max-width: 768px) {
            html, body {
                max-width: 100vw;
                overflow-x: clip;
            }

            body {
                padding: 5px;
            }

            .game-container {
                max-width: 100%;
                width: 100%;
            }

            .game-header {
                padding: 8px;
            }

            .game-header h1 {
                font-size: 1.2em;
                letter-spacing: 1px;
            }

            .game-stats {
                flex-wrap: wrap;
                gap: 6px;
            }

            .stat-box {
                padding: 3px 8px;
                font-size: 0.8em;
            }

            .game-board {
                min-height: auto;
                gap: 8px;
                width: 100%;
            }

            .opponent-area, .player-area {
                padding: 6px;
                width: 100%;
                box-sizing: border-box;
                overflow-x: clip;
            }

            .area-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .player-name {
                font-size: 0.95em;
            }

            .health-bar {
                max-width: 100%;
                width: 100%;
                margin: 0;
            }

            .health-bar-bg {
                height: 16px;
            }

            .health-bar-fill {
                font-size: 0.7em;
            }

            .inline-action-feed {
                min-height: 20px;
            }

            .fighter-zone {
                flex-direction: column;
                align-items: center;
                gap: 6px;
                width: 100%;
            }

            .bench-zone {
                gap: 5px;
                justify-content: center;
                width: 100%;
            }

            .bench-card {
                width: 28%;
                min-width: 75px;
                max-width: 90px;
                padding: 5px;
            }

            .card {
                width: 45%;
                min-width: 130px;
                max-width: 150px;
                padding: 6px;
                flex-shrink: 0;
            }

            .card.fighter-card {
                width: 85%;
                max-width: 200px;
                min-width: 140px;
            }

            .card-header {
                font-size: 0.8em;
                margin-bottom: 4px;
            }

            .card-type {
                font-size: 0.65em;
            }

            .card-stat {
                font-size: 0.7em;
            }

            .card-energy {
                width: 20px;
                height: 20px;
                font-size: 0.75em;
            }

            .card-ability {
                font-size: 0.65em;
            }

            .hand-area {
                gap: 5px;
                padding: 5px;
                min-height: 160px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                width: 100%;
                display: flex;
                flex-wrap: nowrap;
            }

            .center-area {
                padding: 8px;
                max-width: 100%;
                width: 100%;
            }

            #turnIndicator {
                font-size: 1em;
            }

            #actionPrompt {
                font-size: 0.8em;
            }

            .action-buttons {
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.85em;
                width: 100%;
                box-sizing: border-box;
            }

            .modal {
                padding: 10px;
            }

            .modal-content {
                padding: 15px;
                max-width: 95%;
                width: 95%;
                margin: 0 auto;
                box-sizing: border-box;
            }

            .modal-content h2 {
                font-size: 1.4em;
                margin-bottom: 10px;
            }

            .selection-modal .modal-content {
                max-width: 98%;
                width: 98%;
            }

            .select-grid {
                gap: 6px;
                max-width: 100%;
            }

            .select-card {
                width: 28%;
                min-width: 100px;
                max-width: 130px;
                padding: 5px;
            }

            .game-log {
                grid-column: 1;
                grid-row: auto;
                max-height: 300px;
                margin-top: 8px;
                width: 100%;
            }

            .log-entry {
                font-size: 0.75em;
                padding: 3px;
                padding-left: 6px;
            }

            .action-feed {
                top: 10px;
                left: 50%;
                width: 90%;
                max-width: 90%;
            }

            .action-item {
                min-width: auto;
                width: 100%;
                padding: 5px 8px;
                font-size: 0.8em;
            }

            .empty-slot {
                width: 85%;
                max-width: 200px;
                min-width: 140px;
                height: 180px;
                font-size: 0.75em;
            }
        }

        /* Extra small mobile devices */
        @media screen and (max-width: 480px) {
            body {
                padding: 3px;
            }

            .game-header {
                padding: 6px;
            }

            .game-header h1 {
                font-size: 1em;
            }

            .stat-box {
                padding: 3px 6px;
                font-size: 0.75em;
            }

            .stat-label {
                font-size: 0.7em;
            }

            .stat-value {
                font-size: 0.95em;
            }

            .opponent-area, .player-area {
                padding: 5px;
            }

            .player-name {
                font-size: 0.85em;
            }

            .health-bar-bg {
                height: 14px;
            }

            .health-bar-fill {
                font-size: 0.65em;
            }

            .bench-card {
                width: 30%;
                min-width: 70px;
                max-width: 85px;
                padding: 4px;
            }

            .card {
                width: 45%;
                min-width: 110px;
                max-width: 130px;
                padding: 5px;
                flex-shrink: 0;
            }

            .card.fighter-card {
                width: 90%;
                max-width: 180px;
                min-width: 120px;
            }

            .card-header {
                font-size: 0.75em;
                margin-bottom: 3px;
            }

            .card-type {
                font-size: 0.6em;
                margin-bottom: 3px;
            }

            .card-stat {
                font-size: 0.65em;
                margin: 2px 0;
            }

            .card-energy {
                width: 18px;
                height: 18px;
                font-size: 0.7em;
                top: 5px;
                right: 5px;
            }

            .card-ability {
                font-size: 0.6em;
                margin-top: 4px;
                padding-top: 4px;
            }

            .hand-area {
                gap: 4px;
                padding: 4px;
                min-height: 140px;
            }

            .hand-label {
                font-size: 0.8em;
            }

            .hand-counter {
                font-size: 0.75em;
            }

            .center-area {
                padding: 5px;
            }

            #turnIndicator {
                font-size: 0.85em;
            }

            #actionPrompt {
                font-size: 0.7em;
            }

            .btn {
                padding: 8px 12px;
                font-size: 0.8em;
            }

            .modal-content {
                padding: 12px;
            }

            .modal-content h2 {
                font-size: 1.2em;
            }

            .modal-content p {
                font-size: 0.85em;
            }

            .select-card {
                width: 30%;
                min-width: 95px;
                max-width: 115px;
                padding: 4px;
            }

            .game-log {
                max-height: 250px;
                padding: 6px;
            }

            .game-log h3 {
                font-size: 0.85em;
            }

            .log-entry {
                font-size: 0.7em;
            }

            .action-item {
                min-width: auto;
                width: 100%;
                padding: 4px 6px;
                font-size: 0.75em;
            }

            .empty-slot {
                width: 90%;
                max-width: 180px;
                min-width: 120px;
                height: 160px;
                font-size: 0.7em;
            }

            .positional-advantage {
                font-size: 0.6em;
                padding: 1px 3px;
            }

            .stamina-bar-bg {
                height: 6px;
                margin-top: 4px;
            }
        }

        .footer {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            background: linear-gradient(135deg, rgba(25,25,25,0.9), rgba(10,10,10,0.9));
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 0.9em;
        }

        .footer a {
            color: #00e1ff;
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer a:hover {
            color: #00b8d4;
            text-decoration: underline;
        }
    </style>
    <script 
        async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3687058959884961" crossorigin="anonymous">
    </script>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>MMA WARRIORS</h1>
            <div class="game-stats">
                <div class="stat-box">
                    <div class="stat-label">Turn</div>
                    <div class="stat-value" id="turnCounter">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Phase</div>
                    <div class="stat-value" id="currentPhase">Energy</div>
                </div>
            </div>
        </div>

        <div class="game-board">
            <!-- Opponent Area -->
            <div class="opponent-area">
                <div class="area-header">
                    <span class="player-name">OPP</span>
                    <div class="health-bar">
                        <div class="health-bar-bg">
                            <div class="health-bar-fill" id="opponentHealthBar" style="width: 100%;">
                                <span id="opponentHealth">100/100</span>
                            </div>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Energy</div>
                        <div class="stat-value" id="opponentEnergy">0/10</div>
                    </div>
                </div>
                
                <div class="fighter-zone" id="opponentFighterZone">
                    <div class="empty-slot">No Active Fighter</div>
                </div>
                <div class="hand-counter">Hand: <span id="opponentHandCount">5</span></div>
                <!-- per-side inline action feed will render inside fighter zone -->

            </div>

            <!-- Center Action Area -->
            <div class="center-area">
                <h2 id="turnIndicator">YOUR TURN</h2>
                <div class="action-buttons">
                    <button class="btn btn-primary" id="drawCardBtn" onclick="drawCard()">Draw Card</button>
                    <button class="btn btn-primary" id="endTurnBtn" onclick="endTurn()" disabled>End Turn</button>
                </div>
            </div>

            <!-- Player Area -->
            <div class="player-area">
                <div class="area-header">
                    <span class="player-name">YOU</span>
                    <div class="health-bar">
                        <div class="health-bar-bg">
                            <div class="health-bar-fill" id="playerHealthBar" style="width: 100%;">
                                <span id="playerHealth">100/100</span>
                            </div>
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Energy</div>
                        <div class="stat-value" id="playerEnergy">0/10</div>
                    </div>
                </div>
                <div class="fighter-zone" id="playerFighterZone">
                    <div class="empty-slot">No Active Fighter</div>
                </div>
                <!-- per-side inline action feed will render inside fighter zone -->
                <div class="hand-area" id="playerHand">
                    <!-- Player's hand cards will be inserted here -->
                </div>
                <div class="hand-label">Deck: <span id="playerDeckCount">40</span></div>
            </div>

            
        </div>
    </div>
    <div id="actionFeed" class="action-feed" style="display:none"></div>

    <!-- Victory/Defeat Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">Victory!</h2>
            <p id="gameOverMessage">You have defeated your opponent!</p>
            <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <!-- Fighter Selection Modal -->
    <div class="modal selection-modal" id="selectFighterModal">
        <div class="modal-content">
            <h2>Choose Your Fighter</h2>
            <p>Select one fighter to enter the arena.</p>
            <div class="select-grid" id="selectFighterGrid"></div>
        </div>
    </div>

    <!-- Discard Card Modal -->
    <div class="modal selection-modal" id="discardCardModal">
        <div class="modal-content">
            <h2>Hand Full!</h2>
            <p>Choose one card to discard.</p>
            <div class="select-grid" id="discardCardGrid"></div>
        </div>
    </div>

    <div class="footer">
        <a href="privacy.html" target="_blank">Privacy Policy</a>
    </div>

    <script>
        // Game State
        const HAND_LIMIT = 10;
        const gameState = {
            turn: 1,
            currentPlayer: 'player',
            phase: 'setup',
            player: {
                health: 100,
                maxHealth: 100,
                energy: 0,
                maxEnergy: 16,
                deck: [],
                hand: [],
                activeFighter: null,
                positionalAdvantage: false
            },
            opponent: {
                health: 100,
                maxHealth: 100,
                energy: 0,
                maxEnergy: 16,
                deck: [],
                hand: [],
                activeFighter: null,
                positionalAdvantage: false
            }
        };

        // Card Database
        const cardDatabase = {
            fighters: [
                {
                    id: 'fighter_1',
                    name: 'Ilia Topuria',
                    type: 'fighter',
                    striking: 9,
                    grappling: 7,
                    defense: 7,
                    stamina: 38,
                    maxStamina: 38,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_2',
                    name: 'Islam Makhachev',
                    type: 'fighter',
                    striking: 6,
                    grappling: 10,
                    defense: 8,
                    stamina: 40,
                    maxStamina: 40,
                    style: 'Grappler'
                },
                {
                    id: 'fighter_3',
                    name: 'Merab Dvalishvili',
                    type: 'fighter',
                    striking: 6,
                    grappling: 9,
                    defense: 7,
                    stamina: 45,
                    maxStamina: 45,
                    style: 'Grappler'
                },
                {
                    id: 'fighter_4',
                    name: 'Khamzat Chimaev',
                    type: 'fighter',
                    striking: 8,
                    grappling: 9,
                    defense: 7,
                    stamina: 38,
                    maxStamina: 38,
                    style: 'Grappler'
                },
                {
                    id: 'fighter_5',
                    name: 'Alexandre Pantoja',
                    type: 'fighter',
                    striking: 6,
                    grappling: 9,
                    defense: 7,
                    stamina: 38,
                    maxStamina: 38,
                    style: 'Grappler'
                },
                {
                    id: 'fighter_6',
                    name: 'Alex Pereira',
                    type: 'fighter',
                    striking: 10,
                    grappling: 4,
                    defense: 6,
                    stamina: 34,
                    maxStamina: 34,
                    style: 'Striker'
                },
                {
                    id: 'fighter_7',
                    name: 'Alexander Volkanovski',
                    type: 'fighter',
                    striking: 8,
                    grappling: 8,
                    defense: 9,
                    stamina: 42,
                    maxStamina: 42,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_8',
                    name: 'Jack Della Maddalena',
                    type: 'fighter',
                    striking: 9,
                    grappling: 5,
                    defense: 6,
                    stamina: 35,
                    maxStamina: 35,
                    style: 'Striker'
                },
                {
                    id: 'fighter_9',
                    name: 'Tom Aspinall',
                    type: 'fighter',
                    striking: 9,
                    grappling: 7,
                    defense: 7,
                    stamina: 38,
                    maxStamina: 38,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_10',
                    name: 'Dricus Du Plessis',
                    type: 'fighter',
                    striking: 8,
                    grappling: 7,
                    defense: 7,
                    stamina: 40,
                    maxStamina: 40,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_11',
                    name: 'Magomed Ankalaev',
                    type: 'fighter',
                    striking: 7,
                    grappling: 8,
                    defense: 8,
                    stamina: 40,
                    maxStamina: 40,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_12',
                    name: 'Max Holloway',
                    type: 'fighter',
                    striking: 9,
                    grappling: 6,
                    defense: 7,
                    stamina: 45,
                    maxStamina: 45,
                    style: 'Striker'
                },
                {
                    id: 'fighter_13',
                    name: 'Belal Muhammad',
                    type: 'fighter',
                    striking: 6,
                    grappling: 9,
                    defense: 8,
                    stamina: 42,
                    maxStamina: 42,
                    style: 'Grappler'
                },
                {
                    id: 'fighter_14',
                    name: 'Arman Tsarukyan',
                    type: 'fighter',
                    striking: 7,
                    grappling: 8,
                    defense: 7,
                    stamina: 38,
                    maxStamina: 38,
                    style: 'Balanced'
                },
                {
                    id: 'fighter_15',
                    name: 'Charles Oliveira',
                    type: 'fighter',
                    striking: 7,
                    grappling: 10,
                    defense: 6,
                    stamina: 36,
                    maxStamina: 36,
                    style: 'Grappler'
                }
            ],
            techniques: [
                // === STRIKES (Low Cost) ===
                {
                    id: 'tech_jab',
                    name: 'Quick Jab',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 1,
                    damage: 3,
                    effect: 'Basic strike'
                },
                {
                    id: 'tech_legkick',
                    name: 'Leg Kick',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 2,
                    damage: 4,
                    effect: 'Low kick'
                },
                {
                    id: 'tech_bodyshot',
                    name: 'Body Shot',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 2,
                    damage: 4,
                    effect: 'Body punch'
                },
                {
                    id: 'tech_teep',
                    name: 'Teep Kick',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 1,
                    damage: 3,
                    effect: 'Push kick'
                },
                // === STRIKES (Medium Cost) ===
                {
                    id: 'tech_cross',
                    name: 'Power Cross',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 3,
                    damage: 6,
                    effect: 'Strong straight punch'
                },
                {
                    id: 'tech_elbow',
                    name: 'Cutting Elbow',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 3,
                    damage: 5,
                    onHitStatus: { type: 'bleed', amount: 2, turns: 2 },
                    effect: 'Inflict Bleed (2 for 2 turns)'
                },
                {
                    id: 'tech_uppercut',
                    name: 'Uppercut',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 3,
                    damage: 6,
                    effect: 'Rising punch'
                },
                // === STRIKES (High Cost) ===
                {
                    id: 'tech_hook',
                    name: 'Heavy Hook',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 4,
                    damage: 8,
                    effect: 'Powerful hook'
                },
                {
                    id: 'tech_spinning',
                    name: 'Spinning Back Fist',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 4,
                    damage: 7,
                    effect: 'If lands, opponent skips next turn'
                },
                {
                    id: 'tech_kick',
                    name: 'Head Kick',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 4,
                    damage: 10,
                    effect: 'Devastating high kick'
                },
                // === GROUND STRIKE (Keeps Position) ===
                {
                    id: 'tech_gnp',
                    name: 'Ground and Pound',
                    type: 'technique',
                    subtype: 'strike',
                    energy: 2,
                    damage: 6,
                    effect: 'Requires advantage. Bonus damage scales with grappling'
                },
                // === GRAPPLING ===
                {
                    id: 'tech_clinch',
                    name: 'Clinch',
                    type: 'technique',
                    subtype: 'grappling',
                    energy: 2,
                    bonus: 2,
                    damage: 1,
                    effect: 'Control position - gain advantage if successful'
                },
                {
                    id: 'tech_singleleg',
                    name: 'Single Leg Takedown',
                    type: 'technique',
                    subtype: 'grappling',
                    energy: 2,
                    bonus: 2,
                    damage: 2,
                    effect: 'Fast takedown - gain advantage if successful'
                },
                {
                    id: 'tech_takedown',
                    name: 'Double Leg Takedown',
                    type: 'technique',
                    subtype: 'grappling',
                    energy: 3,
                    bonus: 3,
                    damage: 3,
                    effect: 'Powerful takedown - gain advantage if successful'
                },
                {
                    id: 'tech_suplex',
                    name: 'Suplex',
                    type: 'technique',
                    subtype: 'grappling',
                    energy: 4,
                    bonus: 4,
                    damage: 5,
                    effect: 'Devastating slam - gain advantage if successful'
                },
                // === SUBMISSIONS ===
                {
                    id: 'tech_guillotine',
                    name: 'Guillotine Choke',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 3,
                    damage: 10,
                    effect: 'Requires ground. Quick choke'
                },
                {
                    id: 'tech_armbar',
                    name: 'Armbar',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 4,
                    damage: 12,
                    effect: 'Requires ground. Arm lock'
                },
                {
                    id: 'tech_kimura',
                    name: 'Kimura',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 3,
                    damage: 11,
                    effect: 'Requires ground. Shoulder lock'
                },
                {
                    id: 'tech_triangle',
                    name: 'Triangle Choke',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 4,
                    damage: 13,
                    effect: 'Requires ground. Leg choke'
                },
                {
                    id: 'tech_choke',
                    name: 'Rear Naked Choke',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 5,
                    damage: 15,
                    effect: 'Requires ground. Back control'
                },
                {
                    id: 'tech_darce',
                    name: 'D\'Arce Choke',
                    type: 'technique',
                    subtype: 'submission',
                    energy: 4,
                    damage: 14,
                    effect: 'Requires ground. Advanced choke'
                },
                // === DEFENSE ===
                {
                    id: 'tech_block',
                    name: 'Block',
                    type: 'technique',
                    subtype: 'defense',
                    energy: 1,
                    reduction: 5,
                    effect: 'Reduce next incoming attack damage by 5'
                },
                {
                    id: 'tech_parry',
                    name: 'Parry',
                    type: 'technique',
                    subtype: 'defense',
                    energy: 2,
                    reduction: 3,
                    effect: 'Reduce damage by 3 and counter (3 + Striking/4)'
                },
                {
                    id: 'tech_slip',
                    name: 'Slip Counter',
                    type: 'technique',
                    subtype: 'defense',
                    energy: 2,
                    reduction: 8,
                    effect: 'Evade and reduce damage by 8, counter for 4'
                }
            ],
            corners: [
                {
                    id: 'corner_coach',
                    name: 'Master Coach',
                    type: 'corner',
                    energy: 3,
                    effect: 'Active fighter gains +1 to all stats. Draw 1 card.'
                },
                {
                    id: 'corner_training',
                    name: 'Intense Training',
                    type: 'corner',
                    energy: 2,
                    effect: 'Fighter gains +3 Striking until next strike'
                },
                {
                    id: 'corner_medic',
                    name: 'Ringside Medic',
                    type: 'corner',
                    energy: 2,
                    effect: 'Restore 10 Stamina to active fighter'
                }
            ]
        };

        // Initialize game
        function initGame() {
            buildDeck('player');
            buildDeck('opponent');

            shuffleDeck('player');
            shuffleDeck('opponent');

            // Draw opening hands - ensure at least one fighter
            drawOpeningHand('player');
            drawOpeningHand('opponent');

            // Opponent auto-picks best fighter
            const opponentFighter = pickBestFighter(gameState.opponent.hand);
            if (opponentFighter) {
                if (!opponentFighter.strikingBonus) opponentFighter.strikingBonus = 0;
                gameState.opponent.activeFighter = opponentFighter;
                gameState.opponent.hand = gameState.opponent.hand.filter(c => c.uniqueId !== opponentFighter.uniqueId);
                addLog(`Opponent deploys ${opponentFighter.name} to the arena!`, 'opponent', '', 'card-fighter');
                // Show opponent's starting energy (8) upfront to avoid displaying 0 at game start
                gameState.opponent.energy = 8;
                updateUI();
            }

            // Player chooses opening fighter if multiple
            promptOpeningFighterSelection();
        }
        
        function drawOpeningHand(player) {
            // Always draw exactly 5 non-fighter cards + 1 fighter (6 cards total)
            gameState[player].hand = [];
            const deck = gameState[player].deck;

            // Draw 5 non-fighter cards
            let nonFightersDrawn = 0;
            let deckIndex = deck.length - 1;

            while (nonFightersDrawn < 5 && deckIndex >= 0) {
                if (deck[deckIndex].type !== 'fighter') {
                    gameState[player].hand.push(deck.splice(deckIndex, 1)[0]);
                    nonFightersDrawn++;
                }
                deckIndex--;
            }

            // If couldn't find 5 non-fighters (shouldn't happen with 42 non-fighter cards), fill with any cards
            while (gameState[player].hand.length < 5 && deck.length > 0) {
                gameState[player].hand.push(deck.pop());
            }

            // Add exactly 1 fighter from deck
            const fighterIdx = deck.findIndex(c => c.type === 'fighter');
            if (fighterIdx !== -1) {
                const fighter = deck.splice(fighterIdx, 1)[0];
                gameState[player].hand.push(fighter);
            } else {
                // No fighters in deck (shouldn't happen)
                console.error('No fighters found in deck during opening hand!');
            }
        }

        function pickBestFighter(hand) {
            const fighters = hand.filter(c => c.type === 'fighter');
            if (fighters.length === 0) return null;
            return fighters.reduce((best, cur) => {
                const score = cur.striking + cur.grappling + cur.defense + cur.stamina / 10;
                const bestScore = best.striking + best.grappling + best.defense + best.stamina / 10;
                return score > bestScore ? cur : best;
            }, fighters[0]);
        }

        function promptOpeningFighterSelection() {
            const fighters = gameState.player.hand.filter(c => c.type === 'fighter');
            if (fighters.length === 0) {
                // Fallback safety: pick any if somehow missing
                startAfterOpeningSelection();
                return;
            }
            if (fighters.length === 1) {
                const f = fighters[0];
                if (!f.strikingBonus) f.strikingBonus = 0;
                gameState.player.activeFighter = f;
                gameState.player.hand = gameState.player.hand.filter(c => c.uniqueId !== f.uniqueId);
                addLog(`You deploy ${f.name} to the arena!`, 'player', '', 'card-fighter');
                startAfterOpeningSelection();
                return;
            }

            const modal = document.getElementById('selectFighterModal');
            const grid = document.getElementById('selectFighterGrid');
            grid.innerHTML = '';
            fighters.forEach(f => {
                const el = document.createElement('div');
                el.className = 'select-card';
                el.innerHTML = `
                    <div class="card-header">${f.name}</div>
                    <div class="card-type">${f.style}</div>
                    <div class="card-stats">
                        <div class="card-stat"><span class="card-stat-label">Striking:</span><span class="card-stat-value">${f.striking}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Grappling:</span><span class="card-stat-value">${f.grappling}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Defense:</span><span class="card-stat-value">${f.defense}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Stamina:</span><span class="card-stat-value">${f.stamina}/${f.maxStamina}</span></div>
                    </div>
                `;
                el.onclick = () => selectOpeningFighter(f.uniqueId);
                grid.appendChild(el);
            });
            modal.classList.add('active');
        }

        function closeFighterSelect() {
            document.getElementById('selectFighterModal').classList.remove('active');
        }

        function selectOpeningFighter(uniqueId) {
            const f = gameState.player.hand.find(c => c.uniqueId === uniqueId);
            if (!f) return;
            if (!f.strikingBonus) f.strikingBonus = 0;
            gameState.player.activeFighter = f;
            gameState.player.hand = gameState.player.hand.filter(c => c.uniqueId !== uniqueId);
            addLog(`You deploy ${f.name} to the arena!`, 'player', '', 'card-fighter');
            closeFighterSelect();
            startAfterOpeningSelection();
        }

        function promptReplacementFighterSelection() {
            // Collect available fighters from HAND only
            const handFighters = gameState.player.hand.filter(c => c.type === 'fighter');

            if (handFighters.length === 0) {
                // No fighters in hand - player loses
                addLog('You have no fighters in hand!', 'player');
                updateUI();
                setTimeout(() => {
                    endGame('opponent', 'No fighters in hand');
                }, 1000);
                return;
            }

            const availableFighters = handFighters;

            // Show selection modal
            const modal = document.getElementById('selectFighterModal');
            const grid = document.getElementById('selectFighterGrid');
            grid.innerHTML = '';

            availableFighters.forEach(f => {
                const el = document.createElement('div');
                el.className = 'select-card';

                el.innerHTML = `
                    <div class="card-header">${f.name}</div>
                    <div class="card-type">${f.style} (Hand)</div>
                    <div class="card-stats">
                        <div class="card-stat"><span class="card-stat-label">Striking:</span><span class="card-stat-value">${f.striking}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Grappling:</span><span class="card-stat-value">${f.grappling}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Defense:</span><span class="card-stat-value">${f.defense}</span></div>
                        <div class="card-stat"><span class="card-stat-label">Stamina:</span><span class="card-stat-value">${f.stamina}/${f.maxStamina}</span></div>
                    </div>
                `;
                el.onclick = () => selectReplacementFighter(f.uniqueId);
                grid.appendChild(el);
            });

            updateUI();
            modal.classList.add('active');
        }

        function selectReplacementFighter(uniqueId) {
            // Find fighter in hand only
            const fighter = gameState.player.hand.find(c => c.uniqueId === uniqueId);

            if (!fighter) return;

            // Initialize striking bonus
            if (!fighter.strikingBonus) fighter.strikingBonus = 0;

            // Deploy fighter
            gameState.player.activeFighter = fighter;

            // Remove from hand
            gameState.player.hand = gameState.player.hand.filter(c => c.uniqueId !== uniqueId);
            addLog(`You deploy ${fighter.name} to the arena!`, 'player', '', 'card-fighter');

            closeFighterSelect();
            updateUI();
        }

        function startAfterOpeningSelection() {
            // Start game after opening selection
            gameState.phase = 'energy';
            gameState.currentPlayer = 'player';
            startPlayerTurn();
        }

        function buildDeck(player) {
            const deck = [];

            // Add ALL 15 fighters (1 copy of each)
            for (let i = 0; i < cardDatabase.fighters.length; i++) {
                const fighter = JSON.parse(JSON.stringify(cardDatabase.fighters[i]));
                fighter.uniqueId = `${player}_${fighter.id}_${Date.now()}_${i}`;
                deck.push(fighter);
            }

            // Add 48 technique cards (2 copies of each of the 24 techniques)
            for (let copy = 0; copy < 2; copy++) {
                for (let i = 0; i < cardDatabase.techniques.length; i++) {
                    const tech = JSON.parse(JSON.stringify(cardDatabase.techniques[i]));
                    tech.uniqueId = `${player}_${tech.id}_${Date.now()}_${copy}_${i}`;
                    deck.push(tech);
                }
            }

            // Add 12 corner cards (4 copies of each of the 3 corners)
            for (let copy = 0; copy < 4; copy++) {
                for (let i = 0; i < cardDatabase.corners.length; i++) {
                    const corner = JSON.parse(JSON.stringify(cardDatabase.corners[i]));
                    corner.uniqueId = `${player}_${corner.id}_${Date.now()}_${copy}_${i}`;
                    deck.push(corner);
                }
            }

            gameState[player].deck = deck;
        }

        function shuffleDeck(player) {
            const deck = gameState[player].deck;
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function drawCardToHand(player, silent = false) {
            if (gameState[player].deck.length === 0) {
                if (!silent) {
                    addLog(`${player === 'player' ? 'You' : 'Opponent'} cannot draw - deck is empty!`, player);
                    endGame(player === 'player' ? 'opponent' : 'player', 'Deck Out');
                }
                return null;
            }

            // Check current fighters in hand
            const currentFighters = gameState[player].hand.filter(c => c.type === 'fighter');
            const fighterLimit = gameState.phase === 'setup' ? 3 : 2;
            const atFighterLimit = currentFighters.length >= fighterLimit;

            let card = gameState[player].deck.pop();

            // If at fighter limit and drew a fighter, put it back and draw a non-fighter
            if (atFighterLimit && card.type === 'fighter') {
                // Put the fighter back in the deck
                gameState[player].deck.unshift(card);

                // Find a non-fighter card in the deck
                const nonFighterIndex = gameState[player].deck.findIndex(c => c.type !== 'fighter');

                if (nonFighterIndex === -1) {
                    // No non-fighter cards available in deck
                    if (!silent) {
                        addLog(`${player === 'player' ? 'You' : 'Opponent'} cannot draw - only fighters remain and hand is at fighter limit!`, player);
                    }
                    return null;
                }

                // Remove the non-fighter from its position and draw it
                card = gameState[player].deck.splice(nonFighterIndex, 1)[0];

                if (!silent && player === 'player') {
                    addLog(`You drew: ${card.name} (fighter limit reached)`);
                }
            } else {
                if (!silent && player === 'player') {
                    addLog(`You drew: ${card.name}`);
                }
            }

            // If hand is full, need to discard
            if (gameState[player].hand.length >= HAND_LIMIT) {
                if (player === 'player' && !silent) {
                    // Player chooses which card to discard
                    promptCardDiscard(card);
                    return card; // Card will be added after discard selection
                } else {
                    // Opponent or silent draw: auto-discard oldest
                    const discarded = gameState[player].hand.shift();
                    if (!silent) {
                        addLog(`Opponent's hand is full. Discarded ${discarded.name} to draw ${card.name}.`, 'opponent');
                    }
                }
            }

            gameState[player].hand.push(card);

            return card;
        }

        let pendingDrawnCard = null; // Store card waiting to be added after discard

        function promptCardDiscard(drawnCard) {
            // Store the drawn card
            pendingDrawnCard = drawnCard;

            // Show modal with current hand
            const modal = document.getElementById('discardCardModal');
            const grid = document.getElementById('discardCardGrid');
            grid.innerHTML = '';

            addLog(`Your hand is full! Choose a card to discard.`);

            gameState.player.hand.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = 'select-card';

                let cardDisplay = '';
                if (card.type === 'fighter') {
                    cardDisplay = `
                        <div class="card-header">${card.name}</div>
                        <div class="card-type">${card.style}</div>
                        <div class="card-body">
                            <p><strong>Striking:</strong> ${card.striking}</p>
                            <p><strong>Grappling:</strong> ${card.grappling}</p>
                            <p><strong>Defense:</strong> ${card.defense}</p>
                            <p><strong>Stamina:</strong> ${card.stamina}</p>
                        </div>
                    `;
                } else {
                    cardDisplay = `
                        <div class="card-header">${card.name}</div>
                        <div class="card-type">${card.type.toUpperCase()}</div>
                        <div class="card-body">
                            <p><strong>Energy:</strong> ${card.energy}</p>
                            <p>${card.effect}</p>
                        </div>
                    `;
                }

                cardEl.innerHTML = cardDisplay;
                cardEl.onclick = () => selectCardToDiscard(card.uniqueId);
                grid.appendChild(cardEl);
            });

            modal.classList.add('active');
        }

        function selectCardToDiscard(cardId) {
            // Remove the selected card from hand
            const discarded = gameState.player.hand.find(c => c.uniqueId === cardId);
            gameState.player.hand = gameState.player.hand.filter(c => c.uniqueId !== cardId);

            // Add the drawn card
            gameState.player.hand.push(pendingDrawnCard);

            addLog(`You discarded ${discarded.name} to draw ${pendingDrawnCard.name}.`);

            // Close modal
            document.getElementById('discardCardModal').classList.remove('active');
            pendingDrawnCard = null;

            updateUI();
        }

        function drawCard() {
            if (gameState.phase !== 'draw') {
                addLog('You can only draw during the Draw Phase!');
                return;
            }

            const drawn = drawCardToHand('player');
            gameState.phase = 'main';

            document.getElementById('drawCardBtn').disabled = true;
            document.getElementById('endTurnBtn').disabled = false;

            updateUI();
            if (!drawn) {
                addLog(`Hand is full (${HAND_LIMIT}). You must play a card.`);
            }

            // If no actions are available, end the turn automatically
            maybeAutoEndTurn();
        }

        function playCard(card, player) {
            if (player !== 'player' || gameState.currentPlayer !== 'player') return;
            if (gameState.phase !== 'main') {
                addLog('You can only play cards during your Main Phase!');
                return;
            }

            if (card.type === 'fighter') {
                // Can only deploy fighter if no active fighter
                if (gameState.player.activeFighter) {
                    addLog('You already have an active fighter!');
                    return;
                }

                // Initialize fighter stats
                if (!card.strikingBonus) card.strikingBonus = 0;

                // Deploy fighter
                gameState.player.activeFighter = card;
                gameState.player.hand = gameState.player.hand.filter(c => c.uniqueId !== card.uniqueId);
                addLog(`You deploy ${card.name} to the arena!`, 'player', '', 'card-fighter');

                updateUI();
            } else if (card.type === 'technique') {
                if (!gameState.player.activeFighter) {
                    addLog('You need an active fighter to use techniques!');
                    return;
                }

                if (card.energy > gameState.player.energy) {
                    addLog(`Not enough energy! Need ${card.energy}, have ${gameState.player.energy}`);
                    return;
                }

                // Ground and Pound requires positional advantage; block early without announcing
                if (card.id === 'tech_gnp' && !gameState.player.positionalAdvantage) {
                    addLog('You need positional advantage for Ground and Pound!');
                    return;
                }

                // Submissions require either player to have positional advantage (fight on ground)
                if (card.subtype === 'submission' && !gameState.player.positionalAdvantage && !gameState.opponent.positionalAdvantage) {
                    addLog('Fight must be on the ground to use submissions!');
                    return;
                }

                // Check if opponent has active fighter for techniques that require one
                if ((card.subtype === 'strike' || card.subtype === 'submission' || card.subtype === 'grappling') && !gameState.opponent.activeFighter) {
                    addLog('Opponent needs an active fighter to attack!');
                    return;
                }

                // Pre-announce technique to ensure a banner always appears (except for gnp and submissions blocked above)
                if (gameState.player.activeFighter) {
                    const cardTypeClass = card.subtype === 'defense' ? 'card-defense' : 'card-technique';
                    showAction(`${gameState.player.activeFighter.name} uses ${card.name}!`, 'player', '', cardTypeClass);
                }
                executeTechnique(card, 'player');
            } else if (card.type === 'corner') {
                if (!gameState.player.activeFighter) {
                    addLog('You need an active fighter to use corner cards!');
                    return;
                }

                if (card.energy > gameState.player.energy) {
                    addLog(`Not enough energy! Need ${card.energy}, have ${gameState.player.energy}`);
                    return;
                }

                executeCornerCard(card, 'player');
            }

            // After any play, if it's still your main phase and nothing else can be done, auto-end
            maybeAutoEndTurn();
        }

        function executeTechnique(card, player) {
            const attacker = gameState[player];
            const defender = player === 'player' ? gameState.opponent : gameState.player;
            const cardTypeClass = card.subtype === 'defense' ? 'card-defense' : 'card-technique';

            // Safety check - this should have been caught earlier in playCard
            if (!attacker.activeFighter) {
                addLog('You need an active fighter to use techniques!');
                return;
            }

            // Announce technique (for opponent, since player already announces in playCard)
            if (player === 'opponent' && attacker.activeFighter) {
                showAction(`${attacker.activeFighter.name} uses ${card.name}!`, player, '', cardTypeClass);
            }

            attacker.energy -= card.energy;
            attacker.hand = attacker.hand.filter(c => c.uniqueId !== card.uniqueId);

            if (card.subtype === 'strike') {
                // Ground and Pound requires positional advantage on both sides
                if (card.id === 'tech_gnp' && !attacker.positionalAdvantage) {
                    addLog('You need positional advantage for Ground and Pound!', player);
                    attacker.energy += card.energy;
                    attacker.hand.push(card);
                    return;
                }
                // Pre-announce already done, don't duplicate
                const strikingBonus = attacker.activeFighter.strikingBonus || 0;
                let damage = card.damage + attacker.activeFighter.striking + strikingBonus - defender.activeFighter.defense;

                // Apply style bonuses
                if (attacker.activeFighter.style === 'Striker') {
                    damage += 2;
                }

                // Ground and Pound bonus with positional advantage (scales with grappling)
                if (card.id === 'tech_gnp' && attacker.positionalAdvantage) {
                    const gnpBonus = 3 + Math.floor(attacker.activeFighter.grappling / 4);
                    damage += gnpBonus;
                }

                // Ensure damage is never less than the card's displayed damage (BEFORE defense buffs)
                damage = Math.max(card.damage, damage);

                // Apply defender's temporary defense if any (AFTER minimum damage floor)
                let wasBlocked = false;
                if (defender.defenseBuff && defender.defenseBuff.amount) {
                    wasBlocked = true;
                    const reduction = defender.defenseBuff.amount;
                    damage -= reduction;
                    showAction(`Defense: -${reduction} damage blocked!`, player === 'player' ? 'opponent' : 'player', 'advantage', 'card-defense');
                    if (defender.defenseBuff.type === 'parry') {
                        // Parry counter scales with defender's striking skill
                        const counter = 3 + Math.floor(defender.activeFighter.striking / 4);
                        attacker.activeFighter.stamina -= counter;
                        showAction(`Parry counter: ${counter} damage!`, player === 'player' ? 'opponent' : 'player', 'damage', 'card-defense');
                        floatTextOverFighter(player, `-${counter}`, 'damage');
                        checkFighterKO(attacker, player);
                    } else if (defender.defenseBuff.type === 'slip') {
                        // Slip counter deals fixed 4 damage
                        const counter = 4;
                        attacker.activeFighter.stamina -= counter;
                        showAction(`Slip counter: ${counter} damage!`, player === 'player' ? 'opponent' : 'player', 'damage', 'card-defense');
                        floatTextOverFighter(player, `-${counter}`, 'damage');
                        checkFighterKO(attacker, player);
                    }
                    defender.defenseBuff = null;
                }

                // Ensure minimum damage of 1 (can't block all damage)
                damage = Math.max(1, damage);
                defender.activeFighter.stamina -= damage;

                showAction(`${card.name}: ${damage} damage!`, player, 'damage', cardTypeClass);
                floatTextOverFighter(player === 'player' ? 'opponent' : 'player', `-${damage}`, 'damage');

                // On-hit status effects (e.g., Bleed) - only applies if not blocked
                if (card.onHitStatus && card.onHitStatus.type === 'bleed' && !wasBlocked) {
                    defender.activeFighter.status = defender.activeFighter.status || {};
                    defender.activeFighter.status.bleed = { amount: card.onHitStatus.amount, turns: card.onHitStatus.turns };
                    showAction(`Bleed applied (${card.onHitStatus.amount} dmg for ${card.onHitStatus.turns} turns)`, player, 'advantage', cardTypeClass);
                }

                // Spinning Back Fist effect: only applies stagger if not blocked/parried
                if (card.id === 'tech_spinning' && !wasBlocked) {
                    defender.skipNextTurn = true;
                    showAction(`Opponent staggered! Skip next turn.`, player, 'advantage', cardTypeClass);
                    floatTextOverFighter(player === 'player' ? 'opponent' : 'player', 'STAGGERED', 'info');
                }

                // Reset striking bonus after strike is used
                attacker.activeFighter.strikingBonus = 0;

                // Regular strikes (not Ground and Pound) reset the fight to standing - both lose advantage
                if (card.id !== 'tech_gnp') {
                    if (attacker.positionalAdvantage || defender.positionalAdvantage) {
                        attacker.positionalAdvantage = false;
                        defender.positionalAdvantage = false;
                        showAction('Fight returns to standing!', player, 'advantage', cardTypeClass);
                    }
                }

                checkFighterKO(defender, player === 'player' ? 'opponent' : 'player');
                
            } else if (card.subtype === 'grappling') {
                // Pre-announce already done, don't duplicate
                let attackerGrappling = attacker.activeFighter.grappling + card.bonus;

                if (attacker.activeFighter.style === 'Grappler') {
                    attackerGrappling += 2;
                }

                // Calculate defender's grappling defense (GRAPPLING stat, adjusted by stamina)
                let defenderGrappling = defender.activeFighter.grappling;

                // Stamina affects takedown defense - tired fighters are easier to take down
                const staminaPercent = defender.activeFighter.stamina / defender.activeFighter.maxStamina;
                if (staminaPercent < 0.3) {
                    defenderGrappling -= 3; // Very tired
                } else if (staminaPercent < 0.5) {
                    defenderGrappling -= 2; // Tired
                } else if (staminaPercent < 0.7) {
                    defenderGrappling -= 1; // Somewhat tired
                }

                // Calculate takedown success probability
                // Base 50% + 10% for each point of advantage
                const difference = attackerGrappling - defenderGrappling;
                let successChance = 0.5 + (difference * 0.1);

                // Clamp between 10% and 90% (always some chance of success/failure)
                successChance = Math.max(0.1, Math.min(0.9, successChance));

                // Roll for success
                const roll = Math.random();
                if (roll < successChance) {
                    attacker.positionalAdvantage = true;
                    defender.positionalAdvantage = false;
                    defender.defenseBuff = null; // Clear any waiting defensive cards (block/parry/slip)
                    showAction(`${attacker.activeFighter.name} gains Advantage!`, player, 'advantage', cardTypeClass);
                    if (card.damage) {
                        // Add grappling skill scaling to takedown impact damage
                        let takedownDamage = card.damage;
                        const grapplingImpact = Math.floor(attacker.activeFighter.grappling / 3);
                        const grapplingAbsorb = Math.floor(defender.activeFighter.grappling / 3);
                        takedownDamage += grapplingImpact - grapplingAbsorb;
                        // Minimum is card base damage
                        takedownDamage = Math.max(card.damage, takedownDamage);

                        defender.activeFighter.stamina -= takedownDamage;
                        showAction(`Takedown impact: ${takedownDamage} damage!`, player, 'damage', cardTypeClass);
                        floatTextOverFighter(player === 'player' ? 'opponent' : 'player', `-${takedownDamage}`, 'damage');
                        checkFighterKO(defender, player === 'player' ? 'opponent' : 'player');
                    }
                } else {
                    // Stuffed takedown - defender still loses any defensive cards from the scramble
                    defender.defenseBuff = null;
                    // Show stuffed message from defender's perspective for better visibility
                    const defenderName = player === 'player' ? 'opponent' : 'player';
                    showAction(`${defender.activeFighter.name} stuffed the takedown!`, defenderName, 'advantage', cardTypeClass);
                    floatTextOverFighter(defenderName, 'STUFFED', 'info');
                }
                
            } else if (card.subtype === 'submission') {
                // Pre-announce already done, don't duplicate

                // Apply position modifier to base technique damage
                let baseDamage = card.damage;
                if (defender.positionalAdvantage) {
                    baseDamage = Math.floor(baseDamage * 0.6); // 60% penalty from bottom position
                }
                // No bonus for top position - just use base damage

                // Add skill differential using FULL stats (matches striking system)
                let grapplingBonus = attacker.activeFighter.grappling;

                // Grappler style bonus (consistent with Striker getting +2)
                if (attacker.activeFighter.style === 'Grappler') {
                    grapplingBonus += 2;
                }

                const submissionDefense = defender.activeFighter.grappling;
                let damage = baseDamage + grapplingBonus - submissionDefense;

                // Apply minimum damage floor based on modified base
                damage = Math.max(baseDamage, damage);

                // Apply defender's temporary defense if any (AFTER minimum damage floor)
                let wasBlocked = false;
                if (defender.defenseBuff && defender.defenseBuff.amount) {
                    wasBlocked = true;
                    const reduction = defender.defenseBuff.amount;
                    damage -= reduction;
                    showAction(`Defense: -${reduction} damage blocked!`, player === 'player' ? 'opponent' : 'player', 'advantage', 'card-defense');
                    if (defender.defenseBuff.type === 'parry') {
                        // Parry counter scales with defender's striking skill
                        const counter = 3 + Math.floor(defender.activeFighter.striking / 4);
                        attacker.activeFighter.stamina -= counter;
                        showAction(`Parry counter: ${counter} damage!`, player === 'player' ? 'opponent' : 'player', 'damage', 'card-defense');
                        floatTextOverFighter(player, `-${counter}`, 'damage');
                        checkFighterKO(attacker, player);
                    } else if (defender.defenseBuff.type === 'slip') {
                        // Slip counter deals fixed 4 damage
                        const counter = 4;
                        attacker.activeFighter.stamina -= counter;
                        showAction(`Slip counter: ${counter} damage!`, player === 'player' ? 'opponent' : 'player', 'damage', 'card-defense');
                        floatTextOverFighter(player, `-${counter}`, 'damage');
                        checkFighterKO(attacker, player);
                    }
                    defender.defenseBuff = null;
                }

                // Ensure minimum damage of 1 (can't block all damage)
                damage = Math.max(1, damage);

                // Show message with ACTUAL damage that will be dealt
                if (attacker.positionalAdvantage) {
                    showAction(`${card.name} locked in: ${damage} damage!`, player, 'damage', cardTypeClass);
                } else if (defender.positionalAdvantage) {
                    showAction(`${card.name} from bottom: ${damage} damage!`, player, 'damage', cardTypeClass);
                } else {
                    showAction(`${card.name}: ${damage} damage!`, player, 'damage', cardTypeClass);
                }

                defender.activeFighter.stamina -= damage;
                floatTextOverFighter(player === 'player' ? 'opponent' : 'player', `-${damage}`, 'damage');
                checkFighterKO(defender, player === 'player' ? 'opponent' : 'player');
            } else if (card.subtype === 'defense') {
                // Set a one-time defense buff applied to defender on next incoming attack (strike or submission)
                const target = attacker; // playing defense for yourself
                const amount = card.reduction || 0;
                let type = 'block';
                if (card.id === 'tech_parry') {
                    type = 'parry';
                } else if (card.id === 'tech_slip') {
                    type = 'slip';
                }
                target.defenseBuff = { amount, type };
                const counterText = type === 'parry' ? ', counter 3+' : (type === 'slip' ? ', counter 4' : '');
                showAction(`${card.name} ready (-${amount} next DMG${counterText})`, player, 'advantage', cardTypeClass);
            }
            
            updateUI();
        }

        function executeCornerCard(card, player) {
            const p = gameState[player];

            if (!p.activeFighter) {
                addLog(`${player === 'player' ? 'You need' : 'Opponent needs'} an active fighter to use corner cards!`, player);
                return;
            }

            p.energy -= card.energy;
            p.hand = p.hand.filter(c => c.uniqueId !== card.uniqueId);
            showAction(`${card.name} played!`, player, '', 'card-corner');

            if (card.effect.includes('+1 to all stats')) {
                p.activeFighter.striking += 1;
                p.activeFighter.grappling += 1;
                p.activeFighter.defense += 1;
                const drawnCard = drawCardToHand(player);
                if (drawnCard) {
                    showAction(`Effect: +1 all stats, drew ${drawnCard.name}`, player, 'advantage', 'card-corner');
                } else {
                    showAction('Effect: +1 all stats (hand full, no draw)', player, 'advantage', 'card-corner');
                }
            } else if (card.effect.includes('+3 Striking')) {
                // Initialize strikingBonus if it doesn't exist
                if (typeof p.activeFighter.strikingBonus === 'undefined') {
                    p.activeFighter.strikingBonus = 0;
                }
                p.activeFighter.strikingBonus += 3;
                showAction(`Effect: +3 Striking (next strike will deal +${p.activeFighter.strikingBonus} bonus damage)`, player, 'advantage', 'card-corner');
            } else if (card.effect.includes('Restore 10 Stamina')) {
                const oldStamina = p.activeFighter.stamina;
                p.activeFighter.stamina = Math.min(p.activeFighter.maxStamina, p.activeFighter.stamina + 10);
                const actualHeal = p.activeFighter.stamina - oldStamina;
                floatTextOverFighter(player, `+${actualHeal}`, 'heal');
                showAction(`Effect: Restored ${actualHeal} stamina`, player, 'heal', 'card-corner');
            }

            updateUI();
        }

        function checkFighterKO(defender, defenderName) {
            if (defender.activeFighter.stamina <= 0) {
                showAction(`${defender.activeFighter.name} KO'd!`, defenderName, 'ko', 'card-technique');
                defender.activeFighter = null;
                defender.health -= 20;

                // Reset positional advantages when fighter is KO'd (new fight scenario)
                gameState.player.positionalAdvantage = false;
                gameState.opponent.positionalAdvantage = false;

                showAction(`${defenderName === 'player' ? 'You lose' : 'Opponent loses'} 20 health!`, defenderName, 'damage', 'card-technique');
                floatTextOverFighter(defenderName, `-20`, 'damage');

                if (defender.health <= 0) {
                    endGame(defenderName === 'player' ? 'opponent' : 'player', 'Health depleted');
                    return;
                }

                // Check if defender has any fighters left in HAND only
                const handFighters = defender.hand.filter(c => c.type === 'fighter');

                if (handFighters.length === 0) {
                    // No fighters in hand - defender loses immediately
                    addLog(`${defenderName === 'player' ? 'You have' : 'Opponent has'} no fighters in hand!`, defenderName);
                    updateUI();
                    setTimeout(() => {
                        endGame(defenderName === 'player' ? 'opponent' : 'player', 'No fighters in hand');
                    }, 1000);
                    return;
                }

                // Player gets to choose replacement fighter
                if (defenderName === 'player') {
                    setTimeout(() => {
                        promptReplacementFighterSelection();
                    }, 800);
                } else {
                    // Opponent auto-selects (AI behavior)
                    // Deploy from hand only
                    let newFighter = defender.hand.find(c => c.type === 'fighter');
                    if (newFighter) {
                        setTimeout(() => {
                            if (!newFighter.strikingBonus) newFighter.strikingBonus = 0;
                            defender.activeFighter = newFighter;
                            defender.hand = defender.hand.filter(c => c.uniqueId !== newFighter.uniqueId);
                            addLog(`Opponent deploys ${newFighter.name} to the arena!`, defenderName, '', 'card-fighter');
                            updateUI();
                        }, 800);
                    } else {
                        // No fighters in hand - should have been caught earlier but just in case
                        addLog(`Opponent has no fighters in hand!`, defenderName);
                        updateUI();
                        setTimeout(() => {
                            endGame('player', 'No fighters in hand');
                        }, 1000);
                    }
                }

                updateUI();
            }
        }

        function startPlayerTurn() {
            gameState.currentPlayer = 'player';
            gameState.phase = 'energy';

            // Energy phase
            if (gameState.turn === 1) {
                gameState.player.energy = 8; // fixed first-turn energy
            } else {
                gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + 2);
            }

            // Start-of-turn status effects (e.g., Bleed)
            if (gameState.player.activeFighter && gameState.player.activeFighter.status && gameState.player.activeFighter.status.bleed) {
                const b = gameState.player.activeFighter.status.bleed;
                gameState.player.activeFighter.stamina -= b.amount;
                b.turns -= 1;
                showAction(`Bleed: ${b.amount} damage (${Math.max(0,b.turns)} turns left)`, 'player', 'damage', 'card-technique');
                floatTextOverFighter('player', `-${b.amount}`, 'damage');
                if (b.turns <= 0) {
                    delete gameState.player.activeFighter.status.bleed;
                }
                checkFighterKO(gameState.player, 'player');
            }

            // Handle skip-next-turn effect (after energy is applied)
            if (gameState.player.skipNextTurn) {
                gameState.player.skipNextTurn = false;
                addLog('You are staggered and skip this turn!');
                updateUI();
                setTimeout(() => opponentTurn(), 500);
                return;
            }
            
            // Always allow draw phase, even if hand is full (will auto-discard oldest)
            gameState.phase = 'draw';
            document.getElementById('drawCardBtn').disabled = false;
            document.getElementById('endTurnBtn').disabled = false; // Can skip draw and end turn

            if (gameState.player.hand.length >= HAND_LIMIT) {
                addLog(`Your hand is full (${HAND_LIMIT}). Draw to replace oldest card, or skip to Main Phase.`);
            }
            
            addLog(`--- Turn ${gameState.turn}: Your Turn ---`);
            addLog(`You gained energy! Current: ${gameState.player.energy}`);
            
            updateUI();
            if (gameState.phase === 'main') {
                maybeAutoEndTurn();
            }
        }

        function endTurn(isAuto = false) {
            if (gameState.currentPlayer !== 'player') return;

            // If in draw phase, "End Turn" button skips draw and goes to main phase
            if (gameState.phase === 'draw') {
                gameState.phase = 'main';
                document.getElementById('drawCardBtn').disabled = true;
                document.getElementById('endTurnBtn').disabled = false;
                addLog('Skipped draw. Main Phase: Play cards from your hand.');
                updateUI();
                maybeAutoEndTurn();
                return;
            }

            gameState.phase = 'end';

            // Discard down to HAND_LIMIT cards
            while (gameState.player.hand.length > HAND_LIMIT) {
                gameState.player.hand.pop();
            }

            document.getElementById('endTurnBtn').disabled = true;

            if (!isAuto) {
                addLog('Your turn ended.');
            }
            updateUI();

            setTimeout(() => {
                opponentTurn();
            }, 1000);
        }

        function opponentTurn() {
            gameState.currentPlayer = 'opponent';
            gameState.phase = 'energy';
            gameState.turn++;
            
            addLog(`--- Turn ${gameState.turn}: Opponent's Turn ---`, 'opponent');
            
            // Energy phase
            if (gameState.turn === 2) {
                gameState.opponent.energy = 8; // fixed first opponent turn energy
            } else {
                gameState.opponent.energy = Math.min(gameState.opponent.maxEnergy, gameState.opponent.energy + 2);
            }

            // Start-of-turn status effects for opponent
            if (gameState.opponent.activeFighter && gameState.opponent.activeFighter.status && gameState.opponent.activeFighter.status.bleed) {
                const b = gameState.opponent.activeFighter.status.bleed;
                gameState.opponent.activeFighter.stamina -= b.amount;
                b.turns -= 1;
                showAction(`Bleed: ${b.amount} damage (${Math.max(0,b.turns)} turns left)`, 'opponent', 'damage', 'card-technique');
                floatTextOverFighter('opponent', `-${b.amount}`, 'damage');
                if (b.turns <= 0) {
                    delete gameState.opponent.activeFighter.status.bleed;
                }
                checkFighterKO(gameState.opponent, 'opponent');
            }

            // Handle skip-next-turn effect (after energy is applied)
            if (gameState.opponent.skipNextTurn) {
                gameState.opponent.skipNextTurn = false;
                addLog('Opponent is staggered and skips their turn!', 'opponent');
                updateUI();
                setTimeout(() => { startPlayerTurn(); }, 500);
                return;
            }
            
            // Opponent draw phase (skip draw if hand full)
            gameState.phase = 'draw';
            updateUI();
            
            setTimeout(() => {
                // Draw card if hand not full
                if (gameState.opponent.hand.length < HAND_LIMIT) {
                    drawCardToHand('opponent');
                    addLog('Opponent draws a card', 'opponent');
                } else {
                    addLog(`Opponent hand is full (${HAND_LIMIT}).`, 'opponent');
                }
                
                gameState.phase = 'main';
                updateUI();
                
                setTimeout(() => {
                    executeOpponentAI();
                }, 1500);
            }, 1000);
        }

        function executeOpponentAI() {
            // MUST play fighter if needed - this is critical
            if (!gameState.opponent.activeFighter) {
                const fighter = gameState.opponent.hand.find(c => c.type === 'fighter');
                if (fighter) {
                    // Initialize fighter stats
                    if (!fighter.strikingBonus) fighter.strikingBonus = 0;

                    gameState.opponent.activeFighter = fighter;
                    gameState.opponent.hand = gameState.opponent.hand.filter(c => c.uniqueId !== fighter.uniqueId);
                    addLog(`Opponent deploys ${fighter.name} to the arena!`, 'opponent', '', 'card-fighter');
                    updateUI();

                    setTimeout(() => continueOpponentAI(), 1000);
                    return;
                } else {
                    // No fighter available - end turn immediately
                    addLog('Opponent has no fighter to play!', 'opponent');
                    endOpponentTurn();
                    return;
                }
            }

            continueOpponentAI();
        }

        function continueOpponentAI() {
            // Can only play techniques if both players have fighters
            if (!gameState.opponent.activeFighter || !gameState.player.activeFighter) {
                endOpponentTurn();
                return;
            }

            // Check if low stamina - prioritize healing with corner cards
            const needsHealing = gameState.opponent.activeFighter.stamina < (gameState.opponent.activeFighter.maxStamina * 0.4);
            if (needsHealing) {
                const healCard = gameState.opponent.hand.find(c => c.type === 'corner' && c.effect.includes('Restore') && c.energy <= gameState.opponent.energy);
                if (healCard) {
                    executeCornerCard(healCard, 'opponent');
                    setTimeout(() => {
                        if (gameState.opponent.energy > 0 && Math.random() > 0.4) {
                            continueOpponentAI();
                        } else {
                            endOpponentTurn();
                        }
                    }, 1500);
                    return;
                }
            }

            // Sometimes play corner cards strategically
            if (Math.random() > 0.7 && gameState.opponent.energy >= 3) {
                const cornerCard = gameState.opponent.hand.find(c => c.type === 'corner' && c.energy <= gameState.opponent.energy);
                if (cornerCard) {
                    executeCornerCard(cornerCard, 'opponent');
                    setTimeout(() => {
                        if (gameState.opponent.energy > 0 && Math.random() > 0.4) {
                            continueOpponentAI();
                        } else {
                            endOpponentTurn();
                        }
                    }, 1500);
                    return;
                }
            }

            // Simple AI: Play techniques if truly playable
            const playableTechs = gameState.opponent.hand.filter(c => {
                if (c.type !== 'technique') return false;
                if (c.energy > gameState.opponent.energy) return false;
                // Strikes, grappling, and submissions require player to have an active fighter
                if ((c.subtype === 'strike' || c.subtype === 'submission' || c.subtype === 'grappling') && !gameState.player.activeFighter) {
                    return false;
                }
                // Ground and Pound requires positional advantage
                if (c.id === 'tech_gnp' && !gameState.opponent.positionalAdvantage) {
                    return false;
                }
                // Submissions require fight to be on ground (either player has advantage)
                if (c.subtype === 'submission') {
                    return gameState.opponent.positionalAdvantage === true || gameState.player.positionalAdvantage === true;
                }
                // strikes and grappling are playable with both fighters active
                return true;
            });

            if (playableTechs.length > 0) {
                const tech = playableTechs[Math.floor(Math.random() * playableTechs.length)];
                // Execute directly; executeTechnique will display the action and results
                executeTechnique(tech, 'opponent');

                setTimeout(() => {
                    const stillHasPlayable = gameState.opponent.hand.some(c => {
                        if (c.type !== 'technique') return false;
                        if (c.energy > gameState.opponent.energy) return false;
                        // Strikes, grappling, and submissions require player to have an active fighter
                        if ((c.subtype === 'strike' || c.subtype === 'submission' || c.subtype === 'grappling') && !gameState.player.activeFighter) {
                            return false;
                        }
                        // Ground and Pound requires positional advantage
                        if (c.id === 'tech_gnp' && !gameState.opponent.positionalAdvantage) {
                            return false;
                        }
                        // Submissions require fight to be on ground (either player has advantage)
                        if (c.subtype === 'submission') {
                            return gameState.opponent.positionalAdvantage === true || gameState.player.positionalAdvantage === true;
                        }
                        return true;
                    });
                    if (stillHasPlayable && Math.random() > 0.3) {
                        continueOpponentAI();
                    } else {
                        endOpponentTurn();
                    }
                }, 1500);
            } else {
                endOpponentTurn();
            }
        }

        function endOpponentTurn() {
            gameState.phase = 'end';
            
            while (gameState.opponent.hand.length > HAND_LIMIT) {
                gameState.opponent.hand.pop();
            }
            
            addLog('Opponent ends their turn', 'opponent');
            updateUI();
            
            setTimeout(() => {
                startPlayerTurn();
            }, 1000);
        }

        // Attack button removed; clicking cards triggers plays directly


        function endGame(winner, reason) {
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');
            const content = modal.querySelector('.modal-content');
            
            if (winner === 'player') {
                title.textContent = 'VICTORY!';
                message.textContent = `You defeated the opponent! ${reason}`;
                content.classList.remove('defeat');
            } else {
                title.textContent = 'DEFEAT';
                message.textContent = `You were defeated! ${reason}`;
                content.classList.add('defeat');
            }
            
            modal.classList.add('active');
        }

        function addLog(message, player = null, type = '', cardType = '') {
            // Suppress non-critical and redundant messages
            const suppressList = [
                'You drew:',
                'Opponent draws a card',
                '--- Turn',
                'No available actions. Ending turn automatically.',
                'You gained energy!',
                'Main Phase: Play cards from your hand.',
                'Opponent ends their turn',
                'Your turn ended.'
            ];
            for (const marker of suppressList) {
                if (message.startsWith(marker)) return;
            }
            // Route to action banners only (log UI removed)
            showAction(message, player, type, cardType);
        }

        function showAction(message, player = null, type = '', cardType = '') {
            // Resolve owner: if not provided, infer from current turn
            let owner = player;
            if (owner !== 'player' && owner !== 'opponent') {
                owner = (gameState.currentPlayer === 'opponent') ? 'opponent' : 'player';
            }

            // Get the feed for this player
            const feedId = owner === 'opponent' ? 'opponentActionFeed' : 'playerActionFeed';
            let feed = document.getElementById(feedId);

            // If feed doesn't exist yet, create it
            if (!feed) {
                const zoneId = owner === 'opponent' ? 'opponentFighterZone' : 'playerFighterZone';
                const zone = document.getElementById(zoneId);
                if (zone) {
                    feed = document.createElement('div');
                    feed.id = feedId;
                    feed.className = 'inline-action-feed';
                    zone.appendChild(feed);
                }
            }

            if (!feed) return;

            // Create and add the message to the log
            const item = document.createElement('div');
            item.className = 'action-item new-message';
            if (owner === 'opponent') item.classList.add('opponent');
            if (owner === 'player') item.classList.add('player');
            if (type) item.classList.add(type);
            if (cardType) item.classList.add(cardType);
            item.textContent = message;

            // Remove animation class after animation completes
            setTimeout(() => {
                item.classList.remove('new-message');
            }, 300);

            // Append to bottom so newest is at bottom
            feed.appendChild(item);

            // Keep only the 5 most recent messages (remove from top)
            while (feed.children.length > 5) {
                feed.removeChild(feed.firstChild);
            }
        }

        function floatTextOverFighter(owner, text, cls = 'info') {
            const zoneId = owner === 'player' ? 'playerFighterZone' : 'opponentFighterZone';
            const zone = document.getElementById(zoneId);
            if (!zone) return;
            const ft = document.createElement('div');
            ft.className = `float-text ${cls}`;
            ft.textContent = text;
            // attach to first child (card) if present for better positioning
            const target = zone.firstChild && zone.firstChild.classList ? zone.firstChild : zone;
            target.style.position = target.style.position || 'relative';
            target.appendChild(ft);
            setTimeout(() => ft.remove(), 900);
        }

        function updateUI() {
            // Update turn counter
            document.getElementById('turnCounter').textContent = gameState.turn;
            document.getElementById('currentPhase').textContent = gameState.phase.charAt(0).toUpperCase() + gameState.phase.slice(1);
            
            // Update player stats
            document.getElementById('playerEnergy').textContent = `${gameState.player.energy}/${gameState.player.maxEnergy}`;
            document.getElementById('playerHealth').textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            document.getElementById('playerHealthBar').style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
            document.getElementById('playerDeckCount').textContent = gameState.player.deck.length;
            
            // Update opponent stats
            document.getElementById('opponentEnergy').textContent = `${gameState.opponent.energy}/${gameState.opponent.maxEnergy}`;
            document.getElementById('opponentHealth').textContent = `${gameState.opponent.health}/${gameState.opponent.maxHealth}`;
            document.getElementById('opponentHealthBar').style.width = `${(gameState.opponent.health / gameState.opponent.maxHealth) * 100}%`;
            document.getElementById('opponentHandCount').textContent = gameState.opponent.hand.length;
            
            // Update turn indicator
            const turnIndicator = document.getElementById('turnIndicator');
            turnIndicator.textContent = gameState.currentPlayer === 'player' ? 'YOUR TURN' : 'OPPONENT\'S TURN';
            
            // Render fighters
            renderFighter('player');
            renderFighter('opponent');
            // Render player hand
            renderHand();
        }

        // Determine if the player has any valid action to perform in Main Phase
        function hasPlayableAction() {
            if (gameState.currentPlayer !== 'player' || gameState.phase !== 'main') return false;
            const p = gameState.player;
            const o = gameState.opponent;

            // Play a fighter if none active
            if (!p.activeFighter && p.hand.some(c => c.type === 'fighter')) return true;

            // Play a corner card (requires energy and an active fighter to avoid errors)
            if (p.activeFighter && p.hand.some(c => c.type === 'corner' && c.energy <= p.energy)) return true;

            // Techniques
            const hasTechnique = p.hand.some(c => {
                if (c.type !== 'technique') return false;
                if (c.energy > p.energy) return false;
                if (!p.activeFighter) return false;
                if (!o.activeFighter) return false; // strikes/grappling/submission all reference defender's fighter

                if (c.subtype === 'submission') {
                    // Submissions require either player to have advantage (fight on ground)
                    return p.positionalAdvantage === true || o.positionalAdvantage === true;
                }
                // strikes and grappling are allowed with both fighters active
                return true;
            });
            if (hasTechnique) return true;

            return false;
        }

        // End the player's turn automatically if no actions are left
        function maybeAutoEndTurn() {
            if (gameState.currentPlayer === 'player' && gameState.phase === 'main' && !hasPlayableAction()) {
                addLog('No available actions. Ending turn automatically.');
                endTurn(true);
            }
        }

        function renderFighter(player) {
            const zone = document.getElementById(player === 'player' ? 'playerFighterZone' : 'opponentFighterZone');
            const feedId = (player === 'player' ? 'player' : 'opponent') + 'ActionFeed';

            // Find and temporarily detach the existing action feed to preserve all messages
            let existingFeed = document.getElementById(feedId);
            let feedToRestore = null;

            if (existingFeed && existingFeed.parentNode === zone) {
                // Detach it so it won't be cleared with innerHTML
                feedToRestore = zone.removeChild(existingFeed);
            }

            // Clear the zone
            zone.innerHTML = '';

            // Add fighter card or empty slot
            if (!gameState[player].activeFighter) {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'empty-slot';
                emptySlot.textContent = 'No Active Fighter';
                zone.appendChild(emptySlot);
            } else {
                const fighter = gameState[player].activeFighter;
                const card = createFighterCard(fighter, player);
                zone.appendChild(card);
            }

            // Restore the preserved feed with all messages, or create new one if first time
            if (feedToRestore) {
                zone.appendChild(feedToRestore);
            } else {
                const feed = document.createElement('div');
                feed.id = feedId;
                feed.className = 'inline-action-feed';
                zone.appendChild(feed);
            }
        }

        function createFighterCard(fighter, owner) {
            const card = document.createElement('div');
            card.className = `card fighter-card ${owner === 'opponent' ? 'opponent-card' : ''}`;
            
            const staminaPercent = (fighter.stamina / fighter.maxStamina) * 100;
            const staminaColor = staminaPercent > 50 ? '#4ecca3' : staminaPercent > 25 ? '#ffd700' : '#e94560';

            // Show striking with bonus if active
            const strikingBonus = fighter.strikingBonus || 0;
            const strikingDisplay = strikingBonus > 0
                ? `${fighter.striking} <span style="color: #ffd700;">+${strikingBonus}</span>`
                : fighter.striking;

            card.innerHTML = `
                <div class="card-header">${fighter.name}</div>
                <div class="card-type">${fighter.style}</div>
                <div class="card-stats">
                    <div class="card-stat">
                        <span class="card-stat-label">Striking:</span>
                        <span class="card-stat-value">${strikingDisplay}</span>
                    </div>
                    <div class="card-stat">
                        <span class="card-stat-label">Grappling:</span>
                        <span class="card-stat-value">${fighter.grappling}</span>
                    </div>
                    <div class="card-stat">
                        <span class="card-stat-label">Defense:</span>
                        <span class="card-stat-value">${fighter.defense}</span>
                    </div>
                    <div class="card-stat">
                        <span class="card-stat-label">Stamina:</span>
                        <span class="card-stat-value" style="color: ${staminaColor}">${fighter.stamina}/${fighter.maxStamina}</span>
                    </div>
                </div>
                <div class="stamina-bar-bg">
                    <div class="stamina-bar-fill" style="width: ${staminaPercent}%"></div>
                </div>
                ${gameState[owner].positionalAdvantage ? '<span class="positional-advantage">ADVANTAGE</span>' : ''}
            `;
            
            return card;
        }

        function renderHand() {
            const handArea = document.getElementById('playerHand');
            handArea.innerHTML = '';
            
            gameState.player.hand.forEach(card => {
                const cardElement = createHandCard(card);
                handArea.appendChild(cardElement);
            });
        }

        function createHandCard(card) {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';

            if (card.type === 'fighter') {
                cardElement.className += ' fighter-card';
            } else if (card.type === 'technique') {
                cardElement.className += ' technique-card';
                if (card.subtype === 'defense') {
                    cardElement.className += ' defense-card';
                }
            } else if (card.type === 'corner') {
                cardElement.className += ' corner-card';
            }

            let canPlay = false;
            if (card.type === 'fighter') {
                // Can play fighter if no active fighter
                canPlay = !gameState.player.activeFighter;
            } else if (card.type === 'technique') {
                // Can play technique if have enough energy AND have active fighter
                canPlay = card.energy <= gameState.player.energy && gameState.player.activeFighter;
            } else if (card.type === 'corner') {
                // Can play corner if have enough energy AND have active fighter
                canPlay = card.energy <= gameState.player.energy && gameState.player.activeFighter;
            }

            if (!canPlay || gameState.currentPlayer !== 'player' || gameState.phase !== 'main') {
                cardElement.classList.add('disabled');
            } else {
                // Highlight playable cards
                cardElement.classList.add('glow');
            }
            
            if (card.type === 'fighter') {
                const staminaPercent = (card.stamina / card.maxStamina) * 100;
                const staminaColor = staminaPercent > 50 ? '#4ecca3' : staminaPercent > 25 ? '#ffd700' : '#e94560';

                cardElement.innerHTML = `
                    <div class="card-header">${card.name}</div>
                    <div class="card-type">${card.style}</div>
                    <div class="card-stats">
                        <div class="card-stat">
                            <span class="card-stat-label">Striking:</span>
                            <span class="card-stat-value">${card.striking}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">Grappling:</span>
                            <span class="card-stat-value">${card.grappling}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">Defense:</span>
                            <span class="card-stat-value">${card.defense}</span>
                        </div>
                        <div class="card-stat">
                            <span class="card-stat-label">Stamina:</span>
                            <span class="card-stat-value" style="color: ${staminaColor}">${card.stamina}/${card.maxStamina}</span>
                        </div>
                    </div>
                    <div class="stamina-bar-bg">
                        <div class="stamina-bar-fill" style="width: ${staminaPercent}%;"></div>
                    </div>
                `;
            } else if (card.type === 'technique') {
                cardElement.innerHTML = `
                    <div class="card-energy">${card.energy}</div>
                    <div class="card-header">${card.name}</div>
                    <div class="card-type">${card.subtype.charAt(0).toUpperCase() + card.subtype.slice(1)}</div>
                    ${card.damage ? `<div class="card-stat"><span class="card-stat-label">Damage:</span><span class="card-stat-value">${card.damage}</span></div>` : ''}
                    ${card.bonus ? `<div class="card-stat"><span class="card-stat-label">Bonus:</span><span class="card-stat-value">+${card.bonus}</span></div>` : ''}
                    <div class="card-ability">${card.effect}</div>
                `;
            } else if (card.type === 'corner') {
                cardElement.innerHTML = `
                    <div class="card-energy">${card.energy}</div>
                    <div class="card-header">${card.name}</div>
                    <div class="card-type">Corner Card</div>
                    <div class="card-ability">${card.effect}</div>
                `;
            }
            
            cardElement.onclick = () => playCard(card, 'player');
            
            return cardElement;
        }

        // Start the game when page loads
        window.onload = initGame;
    </script>
</body>
</html>